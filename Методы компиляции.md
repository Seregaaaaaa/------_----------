# Список лексем с номерами, таблица переходов автомата

## Список лексем

**Служебные операторы:**
- 1: int
- 2: float
- 3: if 
- 4: else 
- 5: while
- 6: output (Оператор вывода)
- 7: input (Оператор ввода)

**Идентификаторы:**
- 10: Имя переменной (var, a)

**Константы:**
- 11: Целочисленная константа (123, 42)
- 12: Вещественная константа (3.14, 0.5)

**Скобки, разделители:**
- 20: ( (Левая круглая скобка)
- 21: ) (Правая круглая скобка)
- 22: \[ (Левая квадратная скобка)
- 23: ] (Правая квадратная скобка)
- 24: { (Левая фигурная скобка)
- 25: } (Правая фигурная скобка)
- 26: ; (Точка с запятой)
- 27: , (Запятая)
- 28: . (Точка - вещественные числа)

**Операторы:**
- 30: + (Сложение)
- 31: - (Вычитание)
- 32: * (Умножение)
- 33: / (Деление)
- 34: = (Присваивание)
- 35: < (Меньше)
- 36: > (Больше)
- 37: ! (Не равно !=)
- 38: ? (Равно \==)
- 39: & (Логическое И)
- 40: | (Логическое ИЛИ)
- 41: ~ (Унарный минус)

**Специальные символы:**
- 90: Пробел
- 91: Перевод строки (\n)
- 99: Конец файла (EOF)
- 100: Ошибка лексического анализа

## Таблица переходов конечного автомата

| Состояние | буква | цифра | +     | -     | \\*    | /     | =     | <     | >     | !     | .    | ,     | ?     | (     | )     | [     | ]     | {     | }     | ~    | \\|    | &     | ;     | пробел | другие | \\n    | EOF   |
| :-------- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :--- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :--- | :---- | :---- | :---- | :----- | :----- | :---- | :---- |
| **S**     | A/0   | B/1   | E/2   | E/3   | E/4   | E/5   | E/6   | E/7   | E/8   | E/9   | Z/28 | E/11  | E/12  | E/13  | E/14  | E/15  | E/16  | E/17  | E/18  | E/30 | E/31  | E/32  | E/19  | S/20   | Z/21   | S/22  | E/23  |
| **A**     | A/24  | A/24  | E*/25 | E*/25 | E*/25 | E*/25 | E*/25 | E*/25 | E*/25 | E*/25 | Z/28 | E*/25 | E*/25 | E*/25 | E*/25 | E*/25 | E*/25 | E*/25 | E*/25 | Z/28 | E*/31 | E*/32 | E*/25 | E*/25  | E*/25  | E*/25 | E*/23 |
| **B**     | Z/28  | B/26  | E*/27 | E*/27 | E*/27 | E*/27 | E*/27 | E*/27 | E*/27 | E*/27 | C/10 | E*/27 | E*/27 | E*/27 | E*/27 | E*/27 | E*/27 | Z/28  | E*/27 | Z/28 | E*/31 | E*/32 | E*/27 | E*/27  | E*/27  | E*/27 | E*/23 |
| **C**     | Z/28  | D/29  | Z/28  | Z/28  | Z/28  | Z/28  | Z/28  | Z/28  | Z/28  | Z/28  | Z/28 | Z/28  | Z/28  | Z/28  | Z/28  | Z/28  | Z/28  | Z/28  | Z/28  | Z/28 | Z/28  | Z/28  | Z/28  | Z/28   | Z/28   | Z/28  | Z/28  |
| **D**     | Z/28  | D/29  | E*/33 | E*/33 | E*/33 | E*/33 | E*/33 | E*/33 | E*/33 | E*/33 | Z/28 | E*/33 | E*/33 | E*/33 | E*/33 | E*/33 | E*/33 | Z/28  | Z/28  | Z/28 | E*/33 | E*/33 | E*/33 | E*/33  | E*/33  | E*/33 | E*/33 |

### Описание состояний:
1. **S - Начальное состояние:**
    - **Описание:** Это начальное состояние автомата. В этом состоянии автомат находится перед началом разбора новой лексемы. Он ожидает первый символ лексемы.
    - **Переходы из S:**
        - При получении буквы: Переходит в состояние A (начало идентификатора или ключевого слова).            
        - При получении цифры: Переходит в состояние B (начало числовой константы).
        - При получении знаков операций (+, -, \*, /, =, <, >, !, ?, ~, |, &), скобок ((, ), \[, ], {, }), разделителей (,, ;): Переходит в конечное состояние E, немедленно распознавая односимвольную лексему.
        - При получении пробела или перевода строки (\n): Остается в состоянии S, игнорируя данный символ (пропуск разделителей).
        - При получении точки (.): Переходит в состояние ошибки Z..
        - При получении символа конца файла (EOF): Переходит в конечное состояние E, сигнализируя о конце входного потока.
        - При получении любого другого символа ("другие"): Переходит в состояние ошибки Z.

2. **A - Распознавание идентификатора/ключевого слова:**
    - **Описание:** Автомат находится в этом состоянии, когда читает последовательность символов, начавшуюся с буквы. Эта последовательность может быть либо идентификатором (именем переменной), либо ключевым словом.
    - **Переходы из A:**
        - При получении буквы или цифры: Остается в состоянии A, продолжая накапливать символы текущей лексемы.
        - При получении символов . или ~: Согласно таблице, переходит в состояние ошибки Z. Это указывает, что точка или унарный минус не могут следовать сразу за идентификатором/ключевым словом без разделителя в данном языке.
        - При получении любого другого допустимого символа (операторы кроме ~, |, &, скобки, разделители, пробел, \n, EOF): Переходит в конечное состояние E*. Это означает, что текущий прочитанный символ не является частью идентификатора/ключевого слова, а завершает его. Нужно будет проанализировать накопленную строку и обработать этот завершающий символ.

3. **B - Распознавание целой части числа:**
    - **Описание:** Автомат находится в этом состоянии, когда читает последовательность цифр, которая может быть целым числом или целой частью вещественного числа.
    - **Переходы из B:**
        - При получении цифры: Остается в состоянии B, продолжая накапливать цифры.
        - При получении точки (.): Переходит в состояние C, указывая на возможное начало дробной части (вещественное число).
        - При получении любого другого допустимого символа (операторы, |, &, скобки, разделители, пробел, \n, EOF): Переходит в конечное состояние E*, завершая распознавание целой константы.
        - При получении буквы, {, ~: Согласно таблице, переходит в состояние ошибки Z. Эти символы не могут следовать за числом без разделителя.

4. **C - Состояние после точки в числе:**
    - **Описание:** Автомат перешел в это состояние после прочтения точки (.), следующей за последовательностью цифр (из состояния B). Ожидается цифра для формирования дробной части.
    - **Переходы из C:**
        - При получении цифры: Переходит в состояние D, начиная читать дробную часть.
        - При получении любого другого символа: Переходит в состояние ошибки Z. После точки в числе обязательно должна идти хотя бы одна цифра.

5. **D - Распознавание дробной части числа:**
    - **Описание:** Автомат находится в этом состоянии, когда читает цифры после десятичной точки, формируя дробную часть вещественного числа.
    - **Переходы из D:**
        - При получении цифры: Остается в состоянии D, продолжая накапливать цифры дробной части.
        - При получении любого другого допустимого символа (операторы, |, &, скобки, разделители, пробел, \n, EOF): Переходит в конечное состояние E*, завершая распознавание вещественной константы.
        - При получении {, ~, .: Согласно таблице, переходит в состояние ошибки Z.

6. **E - Правильное конечное состояние:**
    - **Описание:** Указание на то, что односимвольная лексема успешно распознана и должна быть "выдана". После выполнения семантической программы автомат возвращается в начальное состояние S.

7. E* - Завершение предыдущей лексемы и выдача:
    - **Описание:** Указывает, что текущий прочитанный символ завершает предыдущую многосимвольную лексему (идентификатор, число). Действие E* означает:
        1. Завершить формирование предыдущей лексемы (на основе накопленного буфера).
        2. Выполнить семантическую программу для выдачи этой завершенной лексемы (проверить на ключевые слова, преобразовать в число и т.д.).
        3. "Вернуть" текущий прочитанный символ обратно во входной поток (или немедленно обработать его, снова начав с состояния S).

8. **Z - Состояние ошибки:**
    - **Описание:** Автомат переходит в это состояние при обнаружении недопустимой последовательности символов (лексической ошибки). Сопровождается генерацией ошибки (лексема тип 100).

### Семантические программы
- **0 (S -> A / буква):** Очистить buffer. Добавить текущий символ (букву) в buffer.
- **1 (S -> B / цифра):** Очистить buffer. Добавить текущий символ (цифру) в buffer.
* **2 (S -> E / +):** Сформировать лексему: Тип=30 (Сложение), Значение="+".
* **3 (S -> E / -):** Сформировать лексему: Тип=31 (Вычитание), Значение="-".
* **4 (S -> E / \*):** Сформировать лексему: Тип=32 (Умножение), Значение="\*".
* **5 (S -> E / /):** Сформировать лексему: Тип=33 (Деление), Значение="/".
* **6 (S -> E / =):** Сформировать лексему: Тип=34 (Присваивание), Значение="=".
* **7 (S -> E / <):** Сформировать лексему: Тип=35 (Меньше), Значение="<".
* **8 (S -> E / >):** Сформировать лексему: Тип=36 (Больше), Значение=">".
* **9 (S -> E / !):** Сформировать лексему: Тип=37 (Не равно), Значение="!".
* **10 (S -> E / ?):** Сформировать лексему: Тип=38 (Равно), Значение="?".
* **11 (S -> E / ():** Сформировать лексему: Тип=20 (Левая круглая скобка), Значение="(".
* **12 (S -> E / )):** Сформировать лексему: Тип=21 (Правая круглая скобка), Значение=")".
* **13 (S -> E / \[):** Сформировать лексему: Тип=22 (Левая квадратная скобка), Значение="\[".
* **14 (S -> E / ]):** Сформировать лексему: Тип=23 (Правая квадратная скобка), Значение="]".
* **15 (S -> E / {):** Сформировать лексему: Тип=24 (Левая фигурная скобка), Значение="{".
* **16 (S -> E / }):** Сформировать лексему: Тип=25 (Правая фигурная скобка), Значение="}".
* **17 (S -> E / ;):** Сформировать лексему: Тип=26 (Точка с запятой), Значение=";".
* **18 (S -> S / пробел):** Игнорировать пробел. Остаться в начальном состоянии S.
* **19 (S -> Z / другие):** Ошибка: Неопознанный символ '\[символ]'. Сформировать лексему: Тип=100 (Ошибка). Пропустить символ.
* **20 (S -> S / \n):** Игнорировать перевод строки. Увеличить счетчик строк. Остаться в начальном состоянии S.
* **21 (S -> Z / другие):** Ошибка: Неопознанный символ '\[символ]'. Сформировать лексему: Тип=100 (Ошибка). Пропустить символ.
* **22 (S -> S / \n):** Игнорировать перевод строки. Увеличить счетчик строк. Остаться в начальном состоянии S.
* **23 (S/A/B/D -> E/E\* / EOF):**
    *   Если из S: Сформировать лексему: Тип=99 (Конец файла). Завершить анализ.
    *   Если из A (E\*): Выполнить действие **25**, затем сформировать лексему Тип=99 (EOF). Завершить анализ.
    *   Если из B (E\*): Выполнить действие **27**, затем сформировать лексему Тип=99 (EOF). Завершить анализ.
    *   Если из D (E\*): Выполнить действие **33**, затем сформировать лексему Тип=99 (EOF). Завершить анализ.
* **24 (A -> A / буква или цифра):** Добавить текущий символ к формируемому идентификатору/ключевому слову.
* **25 (A -> E\* / оператор(не ~), скобка, разделитель, пробел, \n):**
    1. Завершить формирование лексемы из накопленных символов.
    2. Проверить, является ли она ключевым словом (int, float и т.д.).
    3. Сформировать лексему: Тип=1-7 (если ключевое слово) или Тип=10 (если идентификатор), Значение=накопленная строка.
    4. Вернуть текущий прочитанный символ во входной поток (для обработки с начала, из состояния S).
* **26 (B -> B / цифра):** Добавить текущую цифру к формируемому целому числу.
* **27 (B -> E\* / оператор, |, &, скобка, разделитель, пробел, \n):**
    1. Завершить формирование лексемы из накопленных цифр.
    2. Сформировать лексему: Тип=11 (Целочисленная константа), Значение=числовое значение накопленной строки.
    3. Вернуть текущий прочитанный символ во входной поток.
* **28 (Переходы в Z):** Ошибка: Недопустимый символ '[символ]' в данном контексте (например, буква после числа, две точки подряд в числе). Сформировать лексему: Тип=100 (Ошибка). Пропустить символ.
* **29 (C -> D / цифра или D -> D / цифра):** Добавить текущую цифру к формируемой дробной части вещественного числа.
* **30 (S -> E / ~):** Сформировать лексему: Тип=41 (Унарный минус), Значение="~".
* **31 (S/A/B/D -> E/E* / |):**
    *   Если из S: Сформировать лексему: Тип=40 (Логическое ИЛИ), Значение="|".
    *   Если из A/B/D (E\*): Выполнить действие **25**, **27** или **33** соответственно. Затем вернуть символ '|' во входной поток.
* **32 (S/A/B/D -> E/E\* / &):**
    *   Если из S: Сформировать лексему: Тип=39 (Логическое И), Значение="&".
    *   Если из A/B/D (E\*): Выполнить действие **25**, **27** или **33** соответственно. Затем вернуть символ '&' во входной поток.
* **33 (D -> E\* / оператор, |, &, скобка, разделитель, пробел, \n):**
    1. Завершить формирование лексемы из накопленных символов (целая и дробная части).
    2. Сформировать лексему: Тип=12 (Вещественная константа), Значение=числовое значение накопленной строки.
    3. Вернуть текущий прочитанный символ во входной поток.

# КС-грамматика (контекстно-свободная грамматика в форме Бэкуса-Наура)

Нотация:
1. **Нетерминалы в угловых скобках:** Нетерминальные символы (переменные грамматики) заключены в угловые скобки, например: <Программа>, <Оператор>.
2. **Символ ::=:** Используется для определения правила (продукции), отделяя левую часть (один нетерминал) от правой части (последовательность терминалов и/или нетерминалов).
3. **Символ |:** Используется для разделения альтернативных вариантов правой части правила.
4. **Терминалы:** Представлены либо напрямую (как if, else, while, int, float, +, -, \*, /, =, ;, {, }, (, ), \[, ], &, |, ?, !, <, >, ~, ,) либо как классы лексем.
5. **lambda:** Используется для обозначения пустой строки (эпсилон-продукции).

```
<Программа> ::= <Оператор> <Список операторов>

<Оператор> ::= <Объявление и определение переменной>
            | <Объявление переменной>
            | <Объявление массива>
            | <Объявление и определение массива>
            | <Условие IF>
            | <Присваивание>
            | <Цикл WHILE>
            | <Ввод с консоли>
            | <Вывод в консоль>

<Список операторов> ::= lambda | <Оператор> <Список операторов>

<Тип> ::= int | float

<Объявление переменной> ::= <Тип> идентификатор;
<Объявление и определение переменной> ::= <Тип> идентификатор = <Выражение>;

<Объявление массива> ::= <Тип> идентификатор [ <Выражение> ] ;
<Объявление и определение массива> ::= <Тип> идентификатор [] = { <Инициализаторы> };

<Инициализаторы> ::= <Выражение>
            | <Инициализаторы> , <Выражение>

<Условие IF> ::= if ( <Логическое выражение> ) <Блок> <Альтернативное действие>
<Альтернативное действие> ::= else <Блок> 
			| lambda

<Блок> ::= { <Список операторов> }
<Присваивание> ::= идентификатор = <Выражение>
            | идентификатор [ <Выражение> ] = <Выражение>

<Цикл WHILE> ::= while ( <Логическое выражение> ) <Блок>

<Ввод с консоли> ::= input идентификатор [ <Выражение> ];
            | input идентификатор;
<Вывод в консоль> ::= output <Логическое выражение>;

<Логическое выражение> ::= <Логическое выражение> "|" <Логическое И> 
			| <Логическое И>
<Логическое И> ::= <Логическое И> & <Проверка равенства> 
			| <Проверка равенства>
<Проверка равенства> ::= <Проверка равенства> ? <Сравнение> 
			| <Проверка равенства> "!" <Сравнение> 
			| <Сравнение>

<Сравнение> ::= <Сравнение> < <Выражение>
            | <Сравнение> > <Выражение>
            | <Выражение>

<Выражение> ::= <Выражение> + <Терм>
            | <Выражение> - <Терм>
            | <Терм>

<Терм> ::= <Терм> * <Фактор>
	        | <Терм> / <Фактор>
	        | <Фактор>

<Фактор> ::= ~ <Фактор>
            | идентификатор
            | идентификатор [ <Выражение> ]
            | константа
            | ( <Логическое выражение> )
```

# КС-грамматика языка, преобразованная в нестрогую форму Грейбах;

## Нестрогая форма Грейбаха

```
<Программа> ::= int <ОператорDT> <Список операторов>
			            | float <ОператорDT> <Список операторов>
			            | if ( <Логическое выражение> ) <Блок> <Альтернативное действие> <Список операторов>
			            | идентификатор <ПрисваиваниеIdent> <Список операторов>
				        | while ( <Логическое выражение> ) <Блок> <Список операторов>
			            | input <ВводInput> <Список операторов>
			            | output <Выражение> ; <Список операторов>

<Список операторов> ::= lambda
	                    | int <ОператорDT> <Список операторов>
	                    | float <ОператорDT> <Список операторов>
	                    | if ( <Логическое выражение> ) <Блок> <Альтернативное действие> <Список операторов>
	                    | идентификатор <ПрисваиваниеIdent> <Список операторов>
	                    | while ( <Логическое выражение> ) <Блок> <Список операторов>
	                    | input <ВводInput> <Список операторов>
	                    | output <Выражение> ; <Список операторов>

<Инициализаторы> ::= ~ <Фактор> <Терм*> <Выражение*> <Инициализаторы*>
		                | идентификатор <ФакторIdent> <Терм*> <Выражение*> <Инициализаторы*>
			            | константа <Терм*> <Выражение*> <Инициализаторы*>
			            | ( <Логическое выражение> ) <Терм*> <Выражение*> <Инициализаторы*>
<Инициализаторы*> ::= , <Выражение> <Инициализаторы*>
		                | lambda

<Альтернативное действие> ::= else <Блок>
                        | lambda

<Блок> ::= { <Список операторов> }

<Логическое выражение> ::= ~ <Фактор> <Терм*> <Выражение*> <Сравнение*> <Проверка равенства*> <Логическое И*> <Логическое выражение*>
                        | идентификатор <ФакторIdent> <Терм*> <Выражение*> <Сравнение*> <Проверка равенства*> <Логическое И*> <Логическое выражение*>
                        | константа <Терм*> <Выражение*> <Сравнение*> <Проверка равенства*> <Логическое И*> <Логическое выражение*>
                        | ( <Логическое выражение> ) <Терм*> <Выражение*> <Сравнение*> <Проверка равенства*> <Логическое И*> <Логическое выражение*>
<Логическое выражение*> ::= "|" <Логическое И> <Логическое выражение*>
                        | lambda

<Логическое И> ::= ~ <Фактор> <Терм*> <Выражение*> <Сравнение*> <Проверка равенства*> <Логическое И*>
			            | идентификатор <ФакторIdent> <Терм*> <Выражение*> <Сравнение*> <Проверка равенства*> <Логическое И*>
		                | константа <Терм*> <Выражение*> <Сравнение*> <Проверка равенства*> <Логическое И*>
		                | ( <Логическое выражение> ) <Терм*> <Выражение*> <Сравнение*> <Проверка равенства*> <Логическое И*>
<Логическое И*> ::= & <Проверка равенства> <Логическое И*>
		                | lambda

<Проверка равенства> ::= ~ <Фактор> <Терм*> <Выражение*> <Сравнение*> <Проверка равенства*>
		                | идентификатор <ФакторIdent> <Терм*> <Выражение*> <Сравнение*> <Проверка равенства*>
		                | константа <Терм*> <Выражение*> <Сравнение*> <Проверка равенства*>
			            | ( <Логическое выражение> ) <Терм*> <Выражение*> <Сравнение*> <Проверка равенства*>
<Проверка равенства*> ::= ? <Сравнение> <Проверка равенства*>
	                    | ! <Сравнение> <Проверка равенства*>
	                    | lambda

<Сравнение> ::= ~ <Фактор> <Терм*> <Выражение*> <Сравнение*>
						| идентификатор <ФакторIdent> <Терм*> <Выражение*> <Сравнение*>
						| константа <Терм*> <Выражение*> <Сравнение*>
						| ( <Логическое выражение> ) <Терм*> <Выражение*> <Сравнение*>
<Сравнение*> ::= < <Выражение> <Сравнение*>
				        | > <Выражение> <Сравнение*>
			            | lambda

<Выражение> ::= ~ <Фактор> <Терм*> <Выражение*>
						| идентификатор <ФакторIdent> <Терм*> <Выражение*>
						| константа <Терм*> <Выражение*>
						| ( <Логическое выражение> ) <Терм*> <Выражение*>
<Выражение*> ::= lambda
				        | + <Терм> <Выражение*>
				        | - <Терм> <Выражение*>

<Терм> ::= ~ <Фактор> <Терм*>
				        | идентификатор <ФакторIdent> <Терм*>
				        | константа <Терм*>
				        | ( <Логическое выражение> ) <Терм*>
<Терм*> ::= lambda
					    | * <Фактор> <Терм*>
					    | / <Фактор> <Терм*>

<Фактор> ::= ~ <Фактор>
						| идентификатор <ФакторIdent>
					    | константа
					    | ( <Логическое выражение> )
<ФакторIdent> ::= lambda
                        | [ <Выражение> ]

<ВводInput> ::= идентификатор <ВводInputIdent>
<ВводInputIdent> ::= [ <Выражение> ] ;
                        | ;

<ПрисваиваниеIdent> ::= = <Выражение>
                        | [ <Выражение> ] = <Выражение>

<ОператорDTIdent> ::= "=" <Выражение>;
                            | ;
<ОператорDT> ::= идентификатор <ОператорDTIdent>
                            | [ <ОператорDT_[>
<ОператорDT_[> ::= идентификатор ] идентификатор;
                            | ] идентификатор = { <Инициализаторы> }; 
```
# Операции в ОПС (Обратной Польской Строке)

*   **a**: Добавить в ОПС идентификатор переменной (адрес/ссылку).
*   **k**: Добавить в ОПС константу (целую или вещественную).
*   **+**: Добавить в ОПС операцию сложения.
*   **-**: Добавить в ОПС операцию вычитания.
*   **\***: Добавить в ОПС операцию умножения.
*   **/**: Добавить в ОПС операцию деления.
*   **<**: Добавить в ОПС операцию "меньше".
*   **>**: Добавить в ОПС операцию "больше".
*   **!**: Добавить в ОПС операцию "не равно".
*   **?**: Добавить в ОПС операцию "равно".
*   **&**: Добавить в ОПС операцию логического "И".
*   **|**: Добавить в ОПС операцию логического "ИЛИ".
*   **~**: Добавить в ОПС операцию унарного минуса.
*   **=**: Добавить в ОПС операцию присваивания.
*   **w**: Добавить в ОПС операцию вывода (`output`).
*   **r**: Добавить в ОПС операцию ввода (`input`).
*   **i**: Добавить в ОПС операцию индексации массива (получение адреса элемента).
*   **init**: Добавить в ОПС маркер начала инициализации массива (`{...}`).
*   **GEN**: Добавить в ОПС операцию завершения инициализации массива (по списку `{...}`).
*   **j**: Добавить в ОПС операцию безусловного перехода (`j <метка>`).
*   **jf**: Добавить в ОПС операцию условного перехода по false (`jf <метка>`).
# Семантические Программы
*   **Программа 1:** (При распознавании `int` или `float`)
    1.  Записать тип (`int` или `float`) в стек типов (`DataTypes`).

*   **Программа 2:** (При распознавании `[` в объявлении массива)
    1.  Дописать признак массива ("arr") к последнему типу в стеке типов (`DataTypes`).

*   **Программа 3:** (При распознавании идентификатора в объявлении переменной)
    1.  Извлечь тип из стека (`DataTypes`).
    2.  Установить текущий тип для добавления в таблицу символов.
    3.  Проверить имя на повторное объявление в таблице символов. При совпадении – ошибка.
    4.  Если ошибки нет, добавить имя и его тип в таблицу символов.
    5.  Добавить в ОПС операцию `a` и ссылку на идентификатор.

*   **Программа 5:** (При распознавании `=` после `[]` в объявлении массива с инициализацией)
    1.  Добавить в ОПС операцию `init`.

*   **Программа 6:** (Начало цикла `while`)
    1.  Записать текущий адрес `k` (адрес начала проверки условия) в магазин (стек) меток.

*   **Программа 7:** (После условия `while`)
    1.  Записать текущий адрес `k` (адрес команды `jf`) в магазин меток.
    2.  Добавить в ОПС операцию `jf`.
    3.  Добавить в ОПС местозаполнитель для метки перехода. Увеличить `k` на 2.

*   **Программа 8:** (Конец блока `while`)
    1.  Извлечь из магазина меток адрес команды `jf` (AddrJFCmd).
    2.  Извлечь из магазина меток адрес начала цикла (`AddrStart`).
    3.  Заполнить метку для `jf`: `ОПС[AddrJFCmd + 1] = k + 2` (адрес после `j`).
    4.  Добавить в ОПС операцию `j`.
    5.  Добавить в ОПС метку ``AddrStart``. Увеличить `k` на 2.

*   **Программа 9:** (После условия `if`)
    1.  Записать текущий адрес `k` (адрес команды `jf`) в магазин меток.
    2.  Добавить в ОПС операцию `jf`.
    3.  Добавить в ОПС местозаполнитель для метки перехода. Увеличить `k` на 2.

*   **Программа 10:** (Конец `if` без `else`, т.е. после блока `if`, когда `<Альтернативное действие> -> λ`)
    1.  Извлечь из магазина меток адрес команды `jf` (`AddrJFIf`).
    2.  Заполнить метку для `jf`: `ОПС[AddrJFIf + 1] = k`.

*   **Программа 11:** (Начало блока `else`)
    1.  Извлечь из магазина меток адрес команды `jf` (`AddrJFIf`) (помещенный СП 9).
    2.  Записать текущий адрес `k` (адрес команды `j`) в магазин меток (`AddrJSkipElse`).
    3.  Добавить в ОПС операцию `j`.
    4.  Добавить в ОПС местозаполнитель для метки перехода. Увеличить `k` на 2.
    5.  Заполнить метку для `jf`: `ОПС[AddrJFIf + 1] = k` (адрес начала `else`).

*   **Программа 12:** (При распознавании идентификатора в объявлении массива с `{}` )
    1.  Извлечь тип (массив) из стека (`DataTypes`).
    2.  Установить текущий тип для добавления в таблицу символов.
    3.  Проверить имя на повторное объявление. При совпадении – ошибка.
    4.  Если ошибки нет, добавить имя (как массив) в таблицу символов.
    5.  Добавить в ОПС операцию `a` и ссылку на идентификатор.
    6.  Добавить в ОПС операцию `GEN` (или `$GEN`, как в исходном тексте).

# Формат ОПС

1.  **`a <идентификатор>`**-> **`<идентификатор переменной>`** (Прямое использование имени переменной в ОПС)
2.  **`k <константа>`** -> **`<число>`** (Прямое использование числового значения в ОПС)
3.  **`+`** (Сложение) -> **`PLUS`**
4.  **`-`** (Вычитание) -> **`MINUS`**
5.  **`*`** (Умножение) -> **`MULTIPLY`**
6.  **`/`** (Деление) -> **`DIVIDE`**
7.  **`<`** (Меньше) -> **`LT`**
8.  **`>`** (Больше) -> **`GT`**
9.  **`!`** (Не равно) -> **`NEQ
10. **`?`** (Равно) -> **`EQUALS`**
11. **`&`** (Логическое И) -> **`AND`**
12. **`|`** (Логическое ИЛИ) -> **`OR`**
13. **`~`** (Унарный минус) -> **`UNARY_MINUS`**
14. **`w`** (Вывод) -> **`$w`**
15. **`r`** (Ввод) -> **`$r`**
16. **`i`** (Индексация массива) -> **`$i`**
17. **`init`** (Начало инициализации массива) -> **`LIST`**
18. **`GEN`** (Завершение инициализации массива) -> **`$GEN`**
19. **`j <метка>`** (Безусловный переход) -> **`$J <метка>`**
20. **`jf <метка>`** (Условный переход по false) -> **`$JF <метка>`**